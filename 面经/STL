1.STL提供六大组件，彼此可以组合套用：
	1、容器（Containers）：各种数据结构，如：序列式容器vector、list、deque、关联式容器set、map、multiset、multimap。用来存放数据。从实现的角度来看，STL容器是一种class template。

	2、算法（algorithms）：各种常用算法，如：sort、search、copy、erase。从实现的角度来看，STL算法是一种 function template。注意一个问题：任何的一个STL算法，都需要获得由一对迭代器所标示的区间，用来表示操作范围。这一对迭代器所标示的区间都是前闭后开区间，例如[first, last)

	3、迭代器（iterators）：容器与算法之间的胶合剂，是所谓的“泛型指针”。共有五种类型，以及其他衍生变化。从实现的角度来看，迭代器是一种将 operator*、operator->、operator++、operator- - 等指针相关操作进行重载的class template。所有STL容器都有自己专属的迭代器，只有容器本身才知道如何遍历自己的元素。原生指针(native pointer)也是一种迭代器。

	4、仿函数（functors）：行为类似函数，可作为算法的某种策略（policy）。从实现的角度来看，仿函数是一种重载了operator（）的class或class template。一般的函数指针也可视为狭义的仿函数。

	5、配接器（adapters）：一种用来修饰容器、仿函数、迭代器接口的东西。例如：STL提供的queue 和 stack，虽然看似容器，但其实只能算是一种容器配接器，因为它们的底部完全借助deque，所有操作都由底层的deque供应。改变 functors接口者，称为function adapter；改变 container 接口者，称为container adapter；改变iterator接口者，称为iterator adapter。

	6、配置器（allocators）：负责空间配置与管理。从实现的角度来看，配置器是一个实现了动态空间配置、空间管理、空间释放的class template。

	这六大组件的交互关系：container（容器） 通过 allocator（配置器） 取得数据储存空间，algorithm（算法）通过 iterator（迭代器）存取 container（容器） 内容，functor（仿函数） 可以协助 algorithm（算法） 完成不同的策略变化，adapter（配接器） 可以修饰或套接 functor（仿函数）

	序列式容器：
	vector-数组，元素不够时再重新分配内存，拷贝原来数组的元素到新分配的数组中。
	list－单链表。
	deque-分配中央控制器map(并非map容器)，map记录着一系列的固定长度的数组的地址.记住这个map仅仅保存的是数组的地址,真正的数据在数组中存放着.deque先从map中央的位置(因为双向队列，前后都可以插入元素)找到一个数组地址，向该数组中放入数据，数组不够时继续在map中找空闲的数组来存数据。当map也不够时重新分配内存当作新的map,把原来map中的内容copy的新map中。所以使用deque的复杂度要大于vector，尽量使用vector。

	stack-基于deque。
	queue-基于deque。
	heap-完全二叉树，使用最大堆排序，以数组(vector)的形式存放。
	priority_queue-基于heap。
	slist-双向链表。

	关联式容器：
	set,map,multiset,multimap-基于红黑树(RB-tree)，一种加上了额外平衡条件的二叉搜索树。

	hash table-散列表。将待存数据的key经过映射函数变成一个数组(一般是vector)的索引，例如：数据的key%数组的大小＝数组的索引(一般文本通过算法也可以转换为数字)，然后将数据当作此索引的数组元素。有些数据的key经过算法的转换可能是同一个数组的索引值(碰撞问题，可以用线性探测，二次探测来解决)，STL是用开链的方法来解决的，每一个数组的元素维护一个list，他把相同索引值的数据存入一个list，这样当list比较短时执行删除，插入，搜索等算法比较快。

	hash_map,hash_set,hash_multiset,hash_multimap-基于hashtable。

2.list和vector有什么区别？
	vector拥有一段连续的内存空间，因此支持随机存取，如果需要高效的随即存取，而不在乎插入和删除的效率，使用vector。
	list拥有一段不连续的内存空间，因此不支持随机存取，如果需要大量的插入和删除，而不关心随即存取，则应使用list。

22.STL是如何进行内存管理的？(不懂)
	STL空间配置器那点事: http://www.cnblogs.com/lang5230/p/5556611.html

23.红黑树的特性与其在C++ STL中的应用
	map、set、multiset、multimap的底层实现都是红黑树，epoll模型的底层数据结构也是红黑树，linux系统中CFS进程调度算法，也用到红黑树
	红黑树的特性：
	（1）根节点是黑色
	（2）不能有两个连续的红节点
	（3）空指针是黑色
	（4）从任意一个结点出发，到后代中空指针的路径上，均包含相同数量的黑色结点。

25.STL中unordered_map和map的区别
	map是STL中的一个关联容器，提供键值对的数据管理。底层通过红黑树来实现，实际上是二叉排序树和非严格意义上的二叉平衡树。所以在map内部所有的数据都是有序的，且map的查询、插入、删除操作的时间复杂度都是O(logN)。

	unordered_map和map类似，都是存储key-value对，可以通过key快速索引到value，不同的是unordered_map不会根据key进行排序。unordered_map底层是一个防冗余的哈希表，存储时根据key的hash值判断元素是否相同，即unoredered_map内部是无序的。

20.简单介绍vector内存分配方式？STL中的vector的实现，是怎么扩容的？
	先申请一定的大小的数组, 当数组填满之后,另外申请一块原数组两倍大的新数组, 然后把原数组的数据拷贝到新数组, 最后释放原数组的大小。

	vector就是一个动态增长的数组，里面有一个指针指向一片连续的空间，当空间装不下的时候，会申请一片更大的空间，将原来的数据拷贝过去，并释放原来的旧空间。当删除的时候空间并不会被释放，只是清空了里面的数据。对比array是静态空间一旦配置了就不能改变大小。
	vector的动态增加大小的时候，并不是在原有的空间上持续新的空间（无法保证原空间的后面还有可供配置的空间），而是以原大小的两倍另外配置一块较大的空间，然后将原内容拷贝过来，并释放原空间。在VS下是1.5倍扩容，在GCC下是2倍扩容。
	在原来空间不够存储新值时，每次调用push_back方法都会重新分配新的空间以满足新数据的添加操作。如果在程序中频繁进行这种操作，还是比较消耗性能的。
	拓展阅读：https://blog.csdn.net/u010536615/article/details/50452575

21.总结

array
数组 	随机读改 O(1)	无序 	可重复 	支持快速随机访问

vector
数组 	随机读改、尾部插入、尾部删除 O(1) 头部插入、头部删除 O(n) 	无序 	可重复 	支持快速随机访问

list
双向链表 	插入、删除 O(1) 随机读改 O(n)	 无序  	可重复 	支持快速增删

deque
双端队列 	头尾插入、头尾删除 O(1) 	无序 	可重复 	一个中央控制器 + 多个缓冲区，支持首尾快速增删，支持随机访问

stack
deque / list 	顶部插入、顶部删除 O(1)	 	无序 	可重复 	deque 或 list 封闭头端开口，不用 vector 的原因应该是容量大小有限制，扩容耗时

queue
deque / list 	尾部插入、头部删除 O(1) 	无序 	可重复	deque 或 list 封闭头端开口，不用 vector 的原因应该是容量大小有限制，扩容耗时

priority_queue
vector + max-heap 	插入、删除 O(log2n) 	有序 	可重复	vector容器+heap处理规则

set
红黑树 	插入、删除、查找 O(log2n)			有序		不可重复

multiset
红黑树 	插入、删除、查找 O(log2n) 			有序		可重复

map
红黑树 	插入、删除、查找 O(log2n) 			有序 	不可重复

multimap
红黑树 	插入、删除、查找 O(log2n) 			有序 	可重复

hash_set
哈希表 	插入、删除、查找 O(1) 最差 O(n) 	无序 	不可重复

hash_multiset
哈希表 	插入、删除、查找 O(1) 最差 O(n) 	无序 	可重复

hash_map
哈希表 	插入、删除、查找 O(1) 最差 O(n) 	无序 	不可重复

hash_multimap
哈希表	插入、删除、查找 O(1) 最差 O(n) 	无序 	可重复

22.哈希表
	哈希表（Hash table，也叫散列表），是根据关键码值(Key value) 而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。
	关键字——散列函数（哈希函数）——散列地址

	优点：不论哈希表中有多少数据，查找、插入、删除（有时包括删除）只需要接近常量的时间即0(1）的时间级。实际上，这只需要几条机器指令。

	哈希表运算得非常快，在计算机程序中，如果需要在一秒种内查找上千条记录通常使用哈希表（例如拼写检查器)哈希表的速度明显比树快，树的操作通常需要O(N)的时间级。哈希表不仅速度快，编程实现也相对容易。

	如果不需要有序遍历数据，并且可以提前预测数据量的大小。那么哈希表在速度和易用性方面是无与伦比的。

	缺点：它是基于数组的，数组创建后难于扩展，某些哈希表被基本填满时，性能下降得非常严重，所以程序员必须要清楚表中将要存储多少数据（或者准备好定期地把数据转移到更大的哈希表中，这是个费时的过程）。
	1，除法散列法
	2，平方散列法
	3，斐波那契（Fibonacci）散列

	hash函数设计的考虑因素
		1.计算散列地址所需要的时间（即hash函数本身不要太复杂） 
		2.关键字的长度 
		3.表长 
		4.关键字分布是否均匀，是否有规律可循 
		5.设计的hash函数在满足以上条件的情况下尽量减少冲突

	哈希冲突的解决方案
		1.开放定址法 
			线性探测再散列 
			平方探测再散列 
			随机探测在散列（双探测再散列） 
		2.链地址法 
			产生hash冲突后在存储数据后面加一个指针，指向后面冲突的数据 
		3.公共溢出区法 
			建立一个特殊存储空间，专门存放冲突的数据。此种方法适用于数据和冲突较少的情况。 
		4.再散列法 
			准备若干个hash函数，如果使用第一个hash函数发生了冲突，就使用第二个hash函数，第二个也冲突，使用第三个…… 

	hash表的查找
		查找过程和造表过程一致，假设采用开放定址法处理冲突，则查找过程为： 
		对于给定的key，计算hash地址index = H（key） 
		如果数组arr【index】的值为空 则查找不成功 
		如果数组arr【index】== key 则查找成功 
		否则 使用冲突解决方法求下一个地址，直到arr【index】== key或者 arr【index】==null

	hash表的查找效率
		决定hash表查找的ASL因素： 
		1）选用的hash函数 
		2）选用的处理冲突的方法 
		3）hash表的饱和度，装载因子 α=n/m(n表示实际装载数据长度 m为表长) 
		一般情况，假设hash函数是均匀的，则在讨论ASL时可以不考虑它的因素 
		hash表的ASL是处理冲突方法和装载因子的函数 

	hash表的删除
		首先链地址法是可以直接删除元素的，但是开放定址法是不行的，拿前面的双探测再散列来说，假如我们删除了元素1，将其位置置空，那 23就永远找不到了。正确做法应该是删除之后置入一个原来不存在的数据，比如-1

23.红黑树
	红黑树，一种二叉查找树，但在每个结点上增加一个存储位表示结点的颜色，可以是Red或Black。
	通过对任何一条从根到叶子的路径上各个结点着色方式的限制，红黑树确保没有一条路径会比其他路径长出俩倍，因而是接近平衡的。

	二叉查找树
		二叉查找树，也称有序二叉树（ordered binary tree），或已排序二叉树（sorted binary tree），是指一棵空树或者具有下列性质的二叉树：

		若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
		若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
		任意节点的左、右子树也分别为二叉查找树。
		没有键值相等的节点（no duplicate nodes）。

	红黑树的5个性质：
		每个结点要么是红的要么是黑的。  
		根结点是黑的。  
		每个叶结点（叶结点即指树尾端NIL指针或NULL结点）都是黑的。  
		如果一个结点是红的，那么它的两个儿子都是黑的。  
		对于任意结点而言，其到叶结点树尾端NIL指针的每条路径都包含相同数目的黑结点。 

24.b树，b+树
	 B 树又叫平衡多路查找树。一棵m阶的B 树 (注：切勿简单的认为一棵m阶的B树是m叉树，虽然存在四叉树，八叉树，KD树，及vp/R树/R*树/R+树/X树/M树/线段树/希尔伯特R树/优先R树等空间划分树，但与B树完全不等同)的特性如下：

		树中每个结点最多含有m个孩子（m>=2）；

		除根结点和叶子结点外，其它每个结点至少有[ceil(m / 2)]个孩子（其中ceil(x)是一个取上限的函数）；

		若根结点不是叶子结点，则至少有2个孩子（特殊情况：没有孩子的根结点，即根结点为叶子结点，整棵树只有一个根节点）；

		所有叶子结点都出现在同一层，叶子结点不包含任何关键字信息(可以看做是外部接点或查询失败的接点，实际上这些结点不存在，指向这些结点的指针都为null)；（读者反馈@冷岳：这里有错，叶子节点只是没有孩子和指向孩子的指针，这些节点也存在，也有元素。@研究者July：其实，关键是把什么当做叶子结点，因为如红黑树中，每一个NULL指针即当做叶子结点，只是没画出来而已）。

		每个非终端结点中包含有n个关键字信息： (n，P0，K1，P1，K2，P2，......，Kn，Pn)。其中：
		       a)   Ki (i=1...n)为关键字，且关键字按顺序升序排序K(i-1)< Ki。
		       b)   Pi为指向子树根的接点，且指针P(i-1)指向子树种所有结点的关键字均小于Ki，但都大于K(i-1)。 
		       c)   关键字的个数n必须满足： [ceil(m / 2)-1]<= n <= m-1。如下图所示：

25.各种树使用场景
	AVL树：最早的平衡二叉树之一，windows对进程地址空间的管理；
	红黑树：c++ STL中应用，map，set
	B/B+树：用在磁盘文件组织，数据索引和数据库索引
	Trie字典树：用在统计和排序大量字符串，自动机。
